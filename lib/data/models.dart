/// Definition of a chord with its theoretical and practical information.
///
/// Represents a single chord type with all its properties including
/// intervals, notes, and various naming conventions for search and display.
///
/// The [notes] field uses strict theoretical spelling which may include
/// double sharps (##) or double flats (bb). When this occurs,
/// [notesEnharmonicAlt] provides the more common enharmonic equivalent.
class ChordDefinition {
  /// Unique identifier for the chord (e.g., 'C_major', 'A_min7')
  final String id;

  /// Root note of the chord
  final String root;

  /// Quality type (e.g., 'major', 'minor', 'dominant7')
  final String quality;

  /// Intervals from root as semitones (e.g., [0, 4, 7] for major triad)
  final List<int> semitones;

  /// Human-readable display name
  final String displayName;

  /// Strict theoretical spelling (may contain ## / bb)
  final List<String> notes;

  /// Optional: a "sounds like" enharmonic line (only used when notes contain ##/bb)
  final List<String>? notesEnharmonicAlt;

  /// Alternative names for searching (e.g., 'maj', 'M' for major)
  final List<String> aliases;

  /// Search keywords for the chord finder
  final List<String> searchTokens;

  /// Category for filtering (e.g., 'triad', 'dominant', 'altered_dominant')
  final String? category;

  ChordDefinition({
    required this.id,
    required this.root,
    required this.quality,
    required this.semitones,
    required this.displayName,
    required this.notes,
    required this.aliases,
    this.searchTokens = const [],
    this.notesEnharmonicAlt,
    this.category,
  });

  bool get needsSoundsLikeLine {
    return notes.any((n) => n.contains('##') || n.contains('bb'));
  }

  factory ChordDefinition.fromJson(Map<String, dynamic> json) {
    return ChordDefinition(
      id: json['chord_id'] as String,
      root: json['root'] as String,
      quality: json['quality'] as String,
      semitones: List<int>.from(json['formula_semitones'] ?? const <int>[]),
      displayName: (json['display_name'] as String?) ?? '',
      notes: List<String>.from(json['notes'] ?? const <String>[]),
      notesEnharmonicAlt: json['notes_enharmonic_alt'] == null
          ? null
          : List<String>.from(json['notes_enharmonic_alt'] ?? const <String>[]),
      aliases: List<String>.from(json['aliases'] ?? const <String>[]),
      searchTokens: List<String>.from(json['search_tokens'] ?? const <String>[]),
      category: json['category'] as String?,
    );
  }
}

/// Represents a chord quality type (e.g., major, minor, diminished).
///
/// Defines the intervallic formula and naming patterns for a chord type
/// that can be applied to any root note to create a [ChordDefinition].
class ChordQuality {
  /// Unique identifier for the quality
  final String id;

  /// Human-readable name
  final String name;

  /// Interval formula as semitones from root
  final List<int> formula;

  /// Pattern templates for generating chord symbols
  final List<String> aliasesPattern;

  /// Alternative names for this quality
  final List<String> aliases;

  ChordQuality({
    required this.id,
    required this.name,
    required this.formula,
    required this.aliasesPattern,
    required this.aliases,
  });

  factory ChordQuality.fromJson(Map<String, dynamic> json) {
    return ChordQuality(
      id: json['quality_id'] as String,
      name: json['name'] as String,
      formula: List<int>.from(json['formula'] ?? const <int>[]),
      aliasesPattern: List<String>.from(json['aliases_pattern'] ?? const <String>[]),
      aliases: List<String>.from(json['aliases'] ?? const <String>[]),
    );
  }
}

/// Package of diatonic triads and scale information for a key.
///
/// Contains all the data needed to display a key's diatonic chords,
/// including the scale degrees, Roman numeral analysis, chord names,
/// and individual note spellings.
///
/// Generated by [TheoryEngine.buildMajorTriadPack] or similar methods.
class TriadPack {
  /// Display label for the key (e.g., "C Major", "A Natural Minor")
  final String keyLabel;

  /// The seven notes of the scale in order
  final List<String> scale;

  /// Roman numeral analysis (e.g., ['I', 'ii', 'iii', 'IV', 'V', 'vi', 'viiÂ°'])
  final List<String> roman;

  /// Full chord names (e.g., ['C', 'Dm', 'Em', 'F', 'G', 'Am', 'Bdim'])
  final List<String> chordNames;

  /// Individual notes for each chord
  final List<List<String>> notes;

  /// Quality labels for each chord (e.g., 'major', 'minor', 'diminished')
  final List<String> qualities;

  TriadPack({
    required this.keyLabel,
    required this.scale,
    required this.roman,
    required this.chordNames,
    required this.notes,
    required this.qualities,
  });
}

/// Result of transposing a chord to a different root.
///
/// Used by the chord transposer feature to show the same chord quality
/// starting from different root notes.
class TransposedChord {
  /// The transposed chord name (e.g., 'Dm7')
  final String name;

  /// The notes of the transposed chord
  final List<String> notes;

  /// Enharmonic alternative spelling if applicable
  final List<String>? notesEnharmonicAlt;

  TransposedChord(this.name, this.notes, {this.notesEnharmonicAlt});
}
